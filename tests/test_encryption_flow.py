"""Test the full encryption/decryption flow to verify the fix."""

import base64
import json
from unittest.mock import patch

import nacl.public
import nacl.utils
import pytest

from happy_sandbox.auth import decrypt_with_ephemeral_key
from happy_sandbox.encryption import (
    encrypt_with_data_key,
    decrypt_with_data_key,
    libsodium_encrypt_for_public_key,
)


def test_authentication_key_exchange():
    """Test that the authentication flow properly extracts the frontend's public key."""

    # Simulate the frontend's contentKeyPair.publicKey (32 bytes)
    frontend_public_key = nacl.utils.random(32)

    # Create the responseV2Bundle as the mobile app would
    response_v2_bundle = (
        bytes([0]) + frontend_public_key
    )  # version byte + frontend public key

    # Simulate daemon's ephemeral keypair
    daemon_private_key = nacl.utils.random(32)
    daemon_keypair = nacl.public.PrivateKey(daemon_private_key)
    daemon_public_key = bytes(daemon_keypair.public_key)

    # Encrypt the response as the mobile app would
    encrypted_bundle = libsodium_encrypt_for_public_key(
        response_v2_bundle, daemon_public_key
    )

    # Decrypt as the daemon would
    decrypted = decrypt_with_ephemeral_key(encrypted_bundle, daemon_private_key)

    assert decrypted is not None
    assert len(decrypted) == 33  # version byte + 32-byte key
    assert decrypted[0] == 0  # version byte

    # Extract frontend public key as the updated daemon code would
    extracted_frontend_public_key = decrypted[1:33]

    # Verify it matches the original frontend public key
    assert extracted_frontend_public_key == frontend_public_key


def test_end_to_end_encryption_decryption():
    """Test that daemon can generate its own machine data key and encrypt data with it."""

    # Simulate daemon generating its own machine data key
    machine_data_key = nacl.utils.random(32)

    # Test data to encrypt
    test_data = {
        "type": "machineData",
        "timestamp": 1234567890,
        "content": "test machine data",
    }

    # Encrypt with the machine data key (as the daemon would)
    encrypted_data = encrypt_with_data_key(test_data, machine_data_key)

    # Decrypt with the same key (as the daemon should be able to do)
    decrypted_data = decrypt_with_data_key(encrypted_data, machine_data_key)

    assert decrypted_data is not None
    assert decrypted_data == test_data


def test_wrong_key_fails_decryption():
    """Test that using the wrong key fails decryption (as was happening before the fix)."""

    # Original contentDataKey
    content_data_key = nacl.utils.random(32)

    # Wrong key (simulating the random key generated by the old buggy code)
    wrong_key = nacl.utils.random(32)

    # Test data encrypted with correct key
    test_data = {"message": "secret data"}
    encrypted_data = encrypt_with_data_key(test_data, content_data_key)

    # Try to decrypt with wrong key - should fail
    decrypted_data = decrypt_with_data_key(encrypted_data, wrong_key)

    assert decrypted_data is None  # Decryption should fail


def test_machine_data_key_encryption_for_frontend():
    """
    Test the new flow where daemon encrypts its machine data key for the frontend.
    This simulates the complete flow that should resolve the original error.
    """

    # Simulate frontend's key derivation (like in frontend's encryption.ts)
    frontend_master_secret = nacl.utils.random(32)

    # Frontend derives contentDataKey and creates keypair
    # This simulates: const contentKeyPair = sodium.crypto_box_seed_keypair(contentDataKey);
    frontend_content_keypair = nacl.public.PrivateKey.generate()
    frontend_public_key = bytes(frontend_content_keypair.public_key)
    frontend_private_key = bytes(frontend_content_keypair)

    # Daemon generates its own machine data key
    daemon_machine_data_key = nacl.utils.random(32)

    # Daemon encrypts its machine data key FOR the frontend's public key
    encrypted_machine_key = libsodium_encrypt_for_public_key(
        daemon_machine_data_key, frontend_public_key
    )

    # Add version byte as the daemon would do
    versioned_encrypted_key = bytes([0]) + encrypted_machine_key

    # Frontend should be able to decrypt the machine data key
    # This simulates what happens in frontend's decryptEncryptionKey method
    from happy_sandbox.auth import decrypt_with_ephemeral_key

    # Extract the encrypted part (remove version byte)
    if versioned_encrypted_key[0] == 0:
        encrypted_part = versioned_encrypted_key[1:]

        # Frontend decrypts using its private key
        decrypted_key = decrypt_with_ephemeral_key(encrypted_part, frontend_private_key)

        # This should succeed and return the original machine data key
        assert decrypted_key is not None
        assert decrypted_key == daemon_machine_data_key

        # Now frontend can use this key to decrypt machine data
        test_machine_data = {"daemon_status": "running", "pid": 12345}
        encrypted_machine_data = encrypt_with_data_key(
            test_machine_data, daemon_machine_data_key
        )
        decrypted_machine_data = decrypt_with_data_key(
            encrypted_machine_data, daemon_machine_data_key
        )

        assert decrypted_machine_data == test_machine_data


if __name__ == "__main__":
    test_authentication_key_exchange()
    test_end_to_end_encryption_decryption()
    test_wrong_key_fails_decryption()
    test_simulate_main_app_encryption_key_flow()
    print("âœ… All tests passed!")
